<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pump Control Panel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121217; --card-bg: rgba(38, 38, 43, 0.2);
            --text-primary: #f0f0f5; --text-secondary: #a9a9b3;
            --accent-blue: #00a8ff; --accent-green: #20c997; --accent-red: #ff6b6b; --accent-yellow: #ffc107;
            --gauge-track: rgba(255, 255, 255, 0.15); --shadow-color: rgba(0, 0, 0, 0.5);
            --border-color: rgba(255, 255, 255, 0.2);
            --button-bg: transparent;
            --button-hover-bg: rgba(255, 255, 255, 0.1);
        }
        @keyframes move-aurora {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        body {
            font-family: 'Poppins', sans-serif; background-color: var(--bg-color); color: var(--text-primary);
            margin: 0; display: flex; justify-content: center; align-items: flex-start;
            min-height: 100svh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            overflow-y: auto; padding: 2rem 1rem; box-sizing: border-box; position: relative;
        }
        body::before {
            content: ''; position: fixed; top: 50%; left: 50%;
            width: 150vmax; height: 150vmax;
            background-image: radial-gradient(circle, #00a8ff 0%, transparent 35%),
                              radial-gradient(circle, #20c997 0%, transparent 35%),
                              radial-gradient(circle, #ff6b6b 0%, transparent 35%);
            background-position: calc(50% - 40vmin) calc(50% + 20vmin),
                                 calc(50% + 40vmin) calc(50% - 20vmin),
                                 calc(50% - 20vmin) calc(50% - 40vmin);
            background-size: 90vmin 90vmin; background-repeat: no-repeat;
            animation: move-aurora 40s linear infinite;
            filter: blur(120px); opacity: 0.25; z-index: -1;
        }
        .container {
            background: var(--card-bg); backdrop-filter: blur(30px) saturate(180%); -webkit-backdrop-filter: blur(30px) saturate(180%);
            border-radius: 24px; box-shadow: 0 10px 40px var(--shadow-color);
            padding: 2rem; width: 100%; max-width: 420px; text-align: center;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }
        #ripple-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }
        .content-wrapper {
            position: relative; z-index: 1;
        }
        .container.fault-state { border-color: var(--accent-red); box-shadow: 0 0 30px rgba(255, 107, 107, 0.5); }
        h1 {
            margin-top: 0; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 600; font-size: 1.75rem;
        }
        .ip-address { /* Renamed to reflect MQTT status */
            color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 1.5rem; font-weight: 400;
        }
        .gauge-container { position: relative; width: 220px; height: 220px; margin: 0 auto 1.5rem auto; }
        .gauge-svg { width: 100%; height: 100%; transform: rotate(135deg); }
        .gauge-track, .gauge-value-arc { fill: none; stroke-width: 8; stroke-linecap: round; }
        .gauge-track { stroke: var(--gauge-track); }
        .gauge-value-arc { transition: stroke-dashoffset 0.5s ease-in-out, filter 0.5s ease; }
        .gauge-svg.state-safe .gauge-value-arc { stroke: url(#gradient-safe); filter: url(#glow); }
        .gauge-svg.state-fault .gauge-value-arc { stroke: url(#gradient-fault); filter: url(#glow); }
        .gauge-svg.state-idle .gauge-value-arc { stroke: url(#(#gradient-idle); filter: url(#glow); }
        .gauge-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .voltage-value { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); line-height: 1; }
        .voltage-value.fault { color: var(--accent-red); }
        .voltage-unit { font-size: 1.2rem; font-weight: 300; color: var(--text-secondary); }
        .status-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 2rem; }
        .status-item { background-color: rgba(0,0,0,0.2); padding: 1rem; border-radius: 12px; border: 1px solid var(--border-color); }
        .status-item.run-time-item { grid-column: 1 / -1; color: var(--accent-green); }
        .status-item strong { display: block; color: var(--text-secondary); font-size: 0.8rem; font-weight: 600; margin-bottom: 0.35rem; text-transform: uppercase; }
        .status-value { font-weight: 600; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; }
        .status-indicator { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; transition: background-color 0.3s ease; }
        #motor-status-value .status-indicator { background-color: var(--accent-red); }
        #motor-status-value.on .status-indicator { background-color: var(--accent-green); }
        #motor-status-value.on { color: var(--accent-green); }
        #motor-status-value.off { color: var(--text-secondary); }
        #mode-status-value.auto { color: var(--accent-blue); }
        #mode-status-value.manual { color: var(--accent-yellow); }
        .fault-banner {
            display: none; background-color: rgba(255, 107, 107, 0.15); color: var(--accent-red); padding: 1rem;
            border-radius: 12px; margin-bottom: 2rem; font-weight: 600; border: 1px solid var(--accent-red);
        }
        .fault-banner strong { display: block; font-size: 1rem; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem; }
        .btn {
            display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 1rem; font-size: 1rem;
            font-weight: 600; font-family: 'Poppins', sans-serif; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px;
            cursor: pointer; transition: all 0.2s ease; color: white; background-color: var(--button-bg);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .btn:hover { background-color: var(--button-hover-bg); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
        .btn:active { transform: translateY(0); box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; background-color: rgba(255, 255, 255, 0.05); }
        .btn-on { border-color: var(--accent-green); color: var(--accent-green); }
        .btn-off { border-color: var(--accent-red); color: var(--accent-red); }
        .btn-auto { grid-column: 1 / -1; border-color: var(--accent-blue); color: var(--accent-blue); }
        .btn svg { width: 20px; height: 20px; }
        .footer-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .btn-reset { border-color: var(--accent-yellow); color: var(--accent-yellow); }
        .btn-wifi-off { border-color: var(--text-secondary); color: var(--text-secondary); }
        .modal-overlay {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        .modal-content {
            background: var(--card-bg); margin: auto; padding: 2rem; border-radius: 16px;
            width: 90%; max-width: 380px; text-align: center; box-shadow: 0 5px 15px var(--shadow-color);
            border: 1px solid var(--border-color);
        }
        .modal-content h2 { margin-top: 0; font-weight: 600; }
        .modal-buttons { display: flex; gap: 1rem; margin-top: 1.5rem; }
        .modal-buttons .btn { flex: 1; }
    </style>
</head>
<body>
    <div class="container" id="main-container">
        <canvas id="ripple-canvas"></canvas>
        <div class="content-wrapper">
            <h1>Pump Control Panel</h1>
            <div class="ip-address" id="mqtt-status">MQTT Status: Loading Library...</div>
            <div class="gauge-container">
                <svg class="gauge-svg state-idle" viewBox="0 0 120 120">
                    <defs>
                        <linearGradient id="gradient-safe"><stop offset="0%" stop-color="#28a745"/><stop offset="100%" stop-color="#20c997"/></linearGradient>
                        <linearGradient id="gradient-fault"><stop offset="0%" stop-color="#dc3545"/><stop offset="100%" stop-color="#ff6b6b"/></linearGradient>
                        <linearGradient id="gradient-idle"><stop offset="0%" stop-color="#007bff"/><stop offset="100%" stop-color="#00a8ff"/></linearGradient>
                        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                    </defs>
                    <circle class="gauge-track" cx="60" cy="60" r="50"></circle>
                    <circle id="gauge-value-arc" class="gauge-value-arc" cx="60" cy="60" r="50"></circle>
                </svg>
                <div id="gauge-text" class="gauge-text">
                    <div id="voltage-value" class="voltage-value">---</div>
                    <div class="voltage-unit">Volts</div>
                </div>
            </div>
            <div class="status-grid">
                <div class="status-item"><strong>Motor Status</strong><span id="motor-status-value" class="status-value off"><span class="status-indicator"></span>OFF</span></div>
                <div class="status-item"><strong>Control Mode</strong><span id="mode-status-value" class="status-value">---</span></div>
                <div class="status-item run-time-item" id="run-time-item" style="display: none;"><strong>Run Time</strong><span id="run-time-value" class="status-value">00:00</span></div>
            </div>
            <div class="fault-banner" id="fault-banner"><strong>SYSTEM FAULT</strong> Controller in cooldown. Time remaining: <span id="cooldown-timer"></span></div>
            <div class="controls">
                <button id="btn-on" class="btn btn-on"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15V7l7 5-7 5z"/></svg><span>ON</span></button>
                <button id="btn-off" class="btn btn-off"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 12H9V10h2v4zm4 0h-2V10h2v4z"/></svg><span>OFF</span></button>
                <button id="btn-auto" class="btn btn-auto"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5s-2.24-5-5-5h-4zm-1 5h2v2h-2V8z"/></svg><span>AUTO MODE</span></button>
            </div>
            <div class="footer-controls">
                <button id="btn-reset" class="btn btn-reset"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg><span>Reset</span></button>
                <button id="btn-wifi-off" class="btn btn-wifi-off"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12.01 21.49L23.54 9.96c-.43-.33-3.5-2.8-11.53-2.8C3.98 7.16.9 9.63.46 9.96l11.55 11.53.01.01.01-.01z"/></svg><span>WiFi OFF</span></button>
            </div>
        </div>
    </div>
    <div id="resetModal" class="modal-overlay"><div class="modal-content"><h2>Confirm Reset</h2><p>Are you sure you want to restart the controller?</p><div class="modal-buttons"><button id="btn-reset-cancel" class="btn btn-off">Cancel</button><button id="btn-reset-confirm" class="btn btn-on">Yes, Reset</button></div></div></div>
    <div id="wifiOffModal" class="modal-overlay"><div class="modal-content"><h2>Confirm WiFi OFF</h2><p>This will disconnect the controller from the network. Are you sure?</p><div class="modal-buttons"><button id="btn-wifi-off-cancel" class="btn btn-on">Cancel</button><button id="btn-wifi-off-confirm" class="btn btn-off">Yes, Turn Off</button></div></div></div>

    <script defer>
        document.addEventListener('DOMContentLoaded', () => {
            const gaugeValueArc = document.getElementById('gauge-value-arc');
            const voltageValueText = document.getElementById('voltage-value');
            const radius = gaugeValueArc.r.baseVal.value;
            const circumference = 2 * Math.PI * radius;
            let cooldownIntervalId = null;
            let runTimeIntervalId = null;

            // --- MQTT Configuration ---
            const MQTT_BROKER = "broker.hivemq.com"; // Must match ESP8266
            const MQTT_PORT = 8883; // Use WebSocket port for browser (usually 8000 or 8883 for SSL)
            const MQTT_CLIENT_ID_WEB = "WebPumpController_" + Math.random().toString(16).substr(2, 8); // Unique ID for web client
            const MQTT_COMMAND_TOPIC = "pump/controller/commands/3072"; // Updated to use 3072
            const MQTT_STATUS_TOPIC = "pump/controller/status/3072";   // Updated to use 3072

            let client = null; // Paho MQTT client instance

            // Function to load Paho MQTT library and then initialize MQTT connection
            function loadPahoAndInitMqtt() {
                document.getElementById('mqtt-status').textContent = 'MQTT Status: Loading Library...';
                const script = document.createElement('script');
                script.src = "https://unpkg.com/paho-mqtt@1.1.0/paho-mqtt.min.js";
                script.onload = () => {
                    console.log("Paho MQTT library loaded successfully.");
                    // Now that Paho is loaded, proceed with MQTT connection
                    initMqttConnection();
                };
                script.onerror = () => {
                    console.error("Failed to load Paho MQTT library from CDN. Retrying in 5 seconds...");
                    document.getElementById('mqtt-status').textContent = 'MQTT Status: Library Load Failed. Retrying...';
                    setTimeout(loadPahoAndInitMqtt, 5000); // Retry loading the script
                };
                document.head.appendChild(script);
            }

            // Function to initialize MQTT connection
            function initMqttConnection() {
                document.getElementById('mqtt-status').textContent = 'MQTT Status: Connecting...';
                console.log("Attempting MQTT connection...");
                // At this point, Paho.MQTT.Client should be available due to dynamic loading with onload
                if (typeof Paho !== 'undefined' && typeof Paho.MQTT !== 'undefined' && typeof Paho.MQTT.Client !== 'undefined') {
                    client = new Paho.MQTT.Client(MQTT_BROKER, Number(MQTT_PORT), "/mqtt", MQTT_CLIENT_ID_WEB);

                    client.onConnectionLost = onConnectionLost;
                    client.onMessageArrived = onMessageArrived;

                    client.connect({
                        onSuccess: onConnect,
                        onFailure: onFailure,
                        useSSL: true // Set to true if using SSL port (e.g., 8883)
                    });
                } else {
                    // This else block should ideally not be hit if dynamic loading works, but kept for robustness
                    console.error("Paho MQTT client library still not available after load event. Retrying in 1 second.");
                    document.getElementById('mqtt-status').textContent = 'MQTT Status: Library Error. Retrying...';
                    setTimeout(initMqttConnection, 1000);
                }
            }


            function onConnect() {
                console.log("MQTT Connected!");
                document.getElementById('mqtt-status').textContent = 'MQTT Status: Connected';
                client.subscribe(MQTT_STATUS_TOPIC);
                console.log("Subscribed to: " + MQTT_STATUS_TOPIC);
            }

            function onFailure(responseObject) {
                console.error("MQTT Connection Failed: " + responseObject.errorMessage);
                document.getElementById('mqtt-status').textContent = 'MQTT Status: Failed. Retrying...';
                setTimeout(initMqttConnection, 5000); // Retry after 5 seconds
            }

            function onConnectionLost(responseObject) {
                if (responseObject.errorCode !== 0) {
                    console.warn("MQTT Connection Lost: " + responseObject.errorMessage);
                    document.getElementById('mqtt-status').textContent = 'MQTT Status: Disconnected. Reconnecting...';
                    setTimeout(initMqttConnection, 5000); // Retry after 5 seconds
                }
            }

            function onMessageArrived(message) {
                console.log("Message Arrived: " + message.payloadString);
                try {
                    const data = JSON.parse(message.payloadString);
                    if (data && typeof data.voltage !== 'undefined') {
                        updateGauge(data.voltage);
                        updateStatus(data);
                    }
                } catch (e) {
                    console.error("Failed to parse MQTT message payload:", e);
                }
            }

            function publishCommand(command) {
                if (client && client.isConnected()) {
                    const message = new Paho.MQTT.Message(command);
                    message.destinationName = MQTT_COMMAND_TOPIC;
                    client.send(message);
                    console.log("Published command: " + command);
                } else {
                    console.warn("MQTT client not connected. Command not sent.");
                    document.getElementById('mqtt-status').textContent = 'MQTT Status: Not Connected. Command Failed.';
                }
            }

            // --- UI Update Functions (Identical to original) ---
            function updateGauge(voltage) {
                const minVoltage = 0, maxVoltage = 300, safeMin = 165, safeMax = 255;
                const gaugeSvg = document.querySelector('.gauge-svg');
                const clampedVoltage = Math.max(minVoltage, Math.min(maxVoltage, voltage));
                const percentage = (clampedVoltage - minVoltage) / (maxVoltage - minVoltage);
                const arcFactor = 270 / 360;
                const offset = circumference * (1 - (percentage * arcFactor));
                gaugeValueArc.style.strokeDashoffset = offset;
                voltageValueText.textContent = voltage.toFixed(0);
                gaugeSvg.classList.remove('state-safe', 'state-fault', 'state-idle');
                voltageValueText.classList.remove('fault');
                if (voltage >= safeMin && voltage <= safeMax) {
                    gaugeSvg.classList.add('state-safe');
                } else if (voltage > 0) {
                    gaugeSvg.classList.add('state-fault');
                    voltageValueText.classList.add('fault');
                } else {
                    gaugeSvg.classList.add('state-idle');
                }
            }

            function updateStatus(data) {
                const mainContainer = document.getElementById('main-container');
                const motorStatus = document.getElementById('motor-status-value');
                const modeStatus = document.getElementById('mode-status-value');
                const faultBanner = document.getElementById('fault-banner');
                const onButton = document.getElementById('btn-on');
                const runTimeItem = document.getElementById('run-time-item');

                motorStatus.innerHTML = `<span class="status-indicator"></span>${data.motorState ? 'ON' : 'OFF'}`;
                motorStatus.className = `status-value ${data.motorState ? 'on' : 'off'}`;
                modeStatus.textContent = data.mode;
                modeStatus.className = `status-value ${data.mode.toLowerCase()}`;

                if (data.motorState) {
                    runTimeItem.style.display = 'block';
                    if (!runTimeIntervalId) {
                        startRunTimer(data.runTime);
                    }
                } else {
                    runTimeItem.style.display = 'none';
                    if (runTimeIntervalId) {
                        clearInterval(runTimeIntervalId);
                        runTimeIntervalId = null;
                    }
                }

                if (data.isFault) {
                    mainContainer.classList.add('fault-state');
                    faultBanner.style.display = 'block';
                    onButton.disabled = true;
                    if (!cooldownIntervalId) {
                        startCooldownTimer(data.cooldown);
                    }
                } else {
                    mainContainer.classList.remove('fault-state');
                    faultBanner.style.display = 'none';
                    onButton.disabled = false;
                    if (cooldownIntervalId) {
                        clearInterval(cooldownIntervalId);
                        cooldownIntervalId = null;
                    }
                }
            }

            function startCooldownTimer(initialSeconds) {
                let remainingSeconds = initialSeconds;
                const cooldownTimerEl = document.getElementById('cooldown-timer');
                const updateTimer = () => {
                    if (remainingSeconds <= 0) {
                        clearInterval(cooldownIntervalId);
                        cooldownIntervalId = null;
                        // No need to fetchData, MQTT will push updates
                        return;
                    }
                    let minutes = Math.floor(remainingSeconds / 60);
                    let seconds = remainingSeconds % 60;
                    cooldownTimerEl.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                    remainingSeconds--;
                };
                updateTimer();
                cooldownIntervalId = setInterval(updateTimer, 1000);
            }

            function startRunTimer(initialSeconds) {
                let totalSeconds = initialSeconds;
                const runTimeValueEl = document.getElementById('run-time-value');
                const updateTimer = () => {
                    totalSeconds++;
                    let minutes = Math.floor(totalSeconds / 60);
                    let seconds = totalSeconds % 60;
                    runTimeValueEl.textContent = `${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                };
                updateTimer();
                runTimeIntervalId = setInterval(updateTimer, 1000);
            }

            // --- Event Listeners (Now call publishCommand) ---
            const resetModal = document.getElementById('resetModal');
            const wifiOffModal = document.getElementById('wifiOffModal');

            function showResetModal() { resetModal.style.display = 'flex'; }
            function hideResetModal() { resetModal.style.display = 'none'; }
            function confirmReset() {
                hideResetModal();
                publishCommand('RESET');
                // Display a message indicating restart
                document.body.innerHTML = '<div class="container" style="text-align:center;"><h1>Controller Restarting...</h1><p>Please wait a moment for the device to come back online.</p></div>';
            }
            function showWifiOffModal() { wifiOffModal.style.display = 'flex'; }
            function hideWifiOffModal() { wifiOffModal.style.display = 'none'; }
            function confirmWifiOff() {
                hideWifiOffModal();
                publishCommand('WIFI_OFF');
                // Display a message indicating WiFi off
                document.body.innerHTML = '<div class="container" style="text-align:center;"><h1>WiFi Disconnected</h1><p>Controller is now in offline mode. Please restart the device to reconnect.</p></div>';
            }

            document.getElementById('btn-on').addEventListener('click', () => publishCommand('ON'));
            document.getElementById('btn-off').addEventListener('click', () => publishCommand('OFF'));
            document.getElementById('btn-auto').addEventListener('click', () => publishCommand('AUTO'));
            document.getElementById('btn-reset').addEventListener('click', showResetModal);
            document.getElementById('btn-wifi-off').addEventListener('click', showWifiOffModal);
            document.getElementById('btn-reset-cancel').addEventListener('click', hideResetModal);
            document.getElementById('btn-reset-confirm').addEventListener('click', confirmReset);
            document.getElementById('btn-wifi-off-cancel').addEventListener('click', hideWifiOffModal);
            document.getElementById('btn-wifi-off-confirm').addEventListener('click', confirmWifiOff);

            const gaugeTrack = document.querySelector('.gauge-track');
            const arcFactor = 270 / 360;
            gaugeValueArc.style.strokeDasharray = circumference;
            gaugeTrack.style.strokeDasharray = circumference;
            gaugeTrack.style.strokeDashoffset = circumference * (1 - arcFactor);

            // --- Physics-based Particle Splash Effect (Identical to original) ---
            const canvas = document.getElementById('ripple-canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('main-container');
            let particles = [];

            function resizeCanvas() {
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }

            class Particle {
                constructor(x, y) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    this.x = x;
                    this.y = y;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.radius = Math.random() * 2 + 1;
                    this.life = Math.random() * 30 + 40;
                    this.opacity = 1;
                    this.gravity = 0.05;
                    this.friction = 0.98;
                }
                update() {
                    this.vx *= this.friction;
                    this.vy *= this.friction;
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life--;
                    if (this.life < 20) {
                        this.opacity = this.life / 20;
                    }
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.6})`;
                    ctx.fill();
                }
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    if (p.life <= 0) {
                        particles.splice(index, 1);
                    }
                });
                requestAnimationFrame(animate);
            }

            function createSplash(e) {
                const rect = container.getBoundingClientRect();
                let x, y;
                if (e.type.includes('touch')) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(x, y));
                }
            }

            container.addEventListener('mousemove', createSplash);
            container.addEventListener('touchmove', createSplash, { passive: true });

            const resizeObserver = new ResizeObserver(() => resizeCanvas());
            resizeObserver.observe(container);

            resizeCanvas();
            animate();

            // --- Start loading Paho MQTT library when DOM is ready ---
            loadPahoAndInitMqtt();
        });
    </script>
</body>
</html>
